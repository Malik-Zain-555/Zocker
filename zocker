#!/usr/bin/env python3
import sys
import os
import subprocess
import json
from pathlib import Path
import shutil
import random

# ============================================================
#  ZOCKER DIRECTORY LAYOUT
#  ~/.zocker/
#     containers/
#        <name>/
#           meta.json
#           fs/
#              lower/
#              upper/
#              work/
#              merged/
#           logs.txt
#
#  "lower"  = base read-only layer
#  "upper"  = writes (copy-on-write)
#  "work"   = required by overlayfs
#  "merged" = what the container actually sees
# ============================================================

HOME = Path.home()
ZOCKER_HOME = HOME / ".zocker"
CONTAINERS_ROOT = ZOCKER_HOME / "containers"
CONTAINERS_ROOT.mkdir(parents=True, exist_ok=True)

# Root / isolation helpers
def is_root():
    try:
        return os.geteuid() == 0
    except AttributeError:
        # Non-POSIX (e.g. Windows) – treat as non-root
        return False

# ============================================================
#  RANDOM NAMES + COLORS
# ============================================================

ADJ = ["angry", "happy", "sleepy", "wild", "tiny", "rapid", "frozen", "crazy"]
ANI = ["lion", "wolf", "eagle", "tiger", "shark", "panda", "cobra", "falcon"]

COLORS = [
    "\033[92m",  # green
    "\033[93m",  # yellow
    "\033[94m",  # blue
    "\033[95m",  # magenta
    "\033[96m",  # cyan
]
RESET = "\033[0m"

INSTALL_HINTS = {
    "python3": "sudo apt install python3",
    "node": "sudo apt install nodejs",
    "g++": "sudo apt install g++",
    "w3m": "sudo apt install w3m",
    "bash": "bash is usually installed by default on Linux",
    "unshare": "sudo apt install util-linux",
    "chroot": "chroot is part of coreutils/util-linux on most distros",
}

CGROUP_ROOT = Path("/sys/fs/cgroup")

def generate_name():
    """Generate a unique Docker-style container name."""
    while True:
        name = random.choice(ADJ) + "-" + random.choice(ANI)
        if not (CONTAINERS_ROOT / name).exists():
            return name


# ============================================================
#  FS HELPERS (OVERLAY PATHS)
# ============================================================

def get_fs_paths(name: str):
    """
    Return (base, lower, upper, work, merged) dirs for a container.
    base = ~/.zocker/containers/<name>/fs
    """
    base = CONTAINERS_ROOT / name / "fs"
    lower = base / "lower"
    upper = base / "upper"
    work = base / "work"
    merged = base / "merged"
    return base, lower, upper, work, merged


def ensure_fs_tree(name: str):
    """
    Make sure fs/{lower,upper,work,merged} exist. Does NOT mount overlay.
    """
    base, lower, upper, work, merged = get_fs_paths(name)
    for d in (base, lower, upper, work, merged):
        d.mkdir(parents=True, exist_ok=True)
    return base, lower, upper, work, merged


def setup_overlay(name: str):
    """
    Try to mount overlayfs for this container.
    Returns (rootdir, overlay_active: bool)

    rootdir is where shell should chdir (merged if overlay OK, else lower).
    """
    base, lower, upper, work, merged = ensure_fs_tree(name)

    if not is_root():
        print("[overlayfs] Not running as root – cannot mount overlay.")
        print("[overlayfs] Falling back to plain lower dir (no COW).")
        return lower, False

    # Attempt overlay mount (needs root). If it fails, we fall back.
    mount_cmd = [
        "mount",
        "-t", "overlay",
        f"zocker-{name}",
        "-o", f"lowerdir={lower},upperdir={upper},workdir={work}",
        str(merged),
    ]

    try:
        result = subprocess.run(
            mount_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        if result.returncode == 0:
            print(f"[overlayfs] Mounted for container {name}")
            return merged, True
        else:
            print(f"[overlayfs] Mount failed for {name}: {result.stderr.strip()}")
            print("[overlayfs] Falling back to plain lower dir (no COW).")
            return lower, False
    except FileNotFoundError:
        print("[overlayfs] 'mount' command not found. Falling back to lower dir.")
        return lower, False


def teardown_overlay(name: str, overlay_active: bool):
    """
    If overlay was active, try to unmount merged folder.
    """
    if not overlay_active:
        return

    _, _, _, _, merged = get_fs_paths(name)
    if not merged.exists():
        return

    umount_cmd = ["umount", str(merged)]
    try:
        result = subprocess.run(
            umount_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        if result.returncode == 0:
            print(f"[overlayfs] Unmounted for container {name}")
        else:
            print(f"[overlayfs] umount failed for {name}: {result.stderr.strip()}")
    except FileNotFoundError:
        print("[overlayfs] 'umount' command not found (skipping).")


# ============================================================
#  META HELPERS
# ============================================================

def load_meta(name):
    meta_file = CONTAINERS_ROOT / name / "meta.json"
    if not meta_file.exists():
        return None
    with open(meta_file, "r") as f:
        return json.load(f)


def save_meta(name, meta):
    meta_file = CONTAINERS_ROOT / name / "meta.json"
    with open(meta_file, "w") as f:
        json.dump(meta, f, indent=4)


# ============================================================
#  DEPENDENCY CHECK
# ============================================================

def check_dependency(bin_name):
    from shutil import which
    return which(bin_name) is not None


def record_and_report_deps(meta, deps):
    dep_status = {}
    print("\nChecking dependencies:")
    for dep in deps:
        if check_dependency(dep):
            print(f"  [OK] {dep} found")
            dep_status[dep] = "found"
        else:
            print(f"  [MISSING] {dep} NOT found")
            print("    Install with:", INSTALL_HINTS.get(dep, "install manually"))
            dep_status[dep] = "missing"
    meta["deps"] = dep_status
    print("")


# ============================================================
#  CGROUP HELPERS (VERY SIMPLE, BEST-EFFORT)
# ============================================================

def setup_cgroup(name: str, meta: dict):
    """
    Very simple cgroup v2 setup (best-effort).
    It tries to:
      - create /sys/fs/cgroup/zocker/<name>
      - optionally set cpu and memory limits from meta["limits"]
    """
    if not is_root():
        return None

    if not CGROUP_ROOT.exists():
        print("[cgroup] /sys/fs/cgroup not available, skipping cgroup setup.")
        return None

    cg_base = CGROUP_ROOT / "zocker"
    cg_path = cg_base / name

    try:
        cg_path.mkdir(parents=True, exist_ok=True)
    except PermissionError:
        print("[cgroup] Permission denied creating cgroup folder, skipping.")
        return None

    limits = meta.get("limits", {})
    # CPU limit: expect something like {"cpu.max": "50000 100000"}
    cpu_max = limits.get("cpu.max")
    if cpu_max:
        try:
            (cg_path / "cpu.max").write_text(cpu_max)
            print(f"[cgroup] cpu.max set to {cpu_max}")
        except Exception as e:
            print(f"[cgroup] Failed to set cpu.max: {e}")

    mem_max = limits.get("memory.max")
    if mem_max:
        try:
            (cg_path / "memory.max").write_text(str(mem_max))
            print(f"[cgroup] memory.max set to {mem_max}")
        except Exception as e:
            print(f"[cgroup] Failed to set memory.max: {e}")

    meta["cgroup_path"] = str(cg_path)
    return cg_path


def add_pid_to_cgroup(cg_path: Path, pid: int):
    """
    Add a pid to the cgroup's cgroup.procs (best-effort).
    """
    try:
        procs_file = cg_path / "cgroup.procs"
        procs_file.write_text(str(pid))
        print(f"[cgroup] Added PID {pid} to {procs_file}")
    except Exception as e:
        print(f"[cgroup] Failed to add PID to cgroup: {e}")


def teardown_cgroup(meta: dict):
    """
    Try to remove cgroup directory on container stop.
    """
    if not is_root():
        return

    cg_path_str = meta.get("cgroup_path")
    if not cg_path_str:
        return

    cg_path = Path(cg_path_str)
    try:
        # Try to remove; will fail if processes still inside
        cg_path.rmdir()
        print(f"[cgroup] Removed cgroup {cg_path}")
    except Exception:
        # Ignore if busy
        pass


# ============================================================
#  CREATE (MANUAL)
# ============================================================

def cmd_create():
    if len(sys.argv) < 4:
        print("Usage: zocker create <runner> <file>")
        return

    runner = sys.argv[2]
    filename = sys.argv[3]

    name = generate_name()
    folder = CONTAINERS_ROOT / name
    folder.mkdir(parents=True)

    _, lower, upper, work, merged = ensure_fs_tree(name)

    if Path(filename).exists():
        shutil.copy(filename, lower / filename)
    else:
        print("WARNING: source file not found; container created without it.")

    color = random.choice(COLORS)

    meta = {
        "name": name,
        "status": "created",
        "runner": runner,
        "command": [runner, filename],
        "pid": None,
        "color": color,
        "cpu": "high",
        "overlay": False,
        "limits": {
            # example soft limits – can be tuned per container
            # cgroup v2 style values:
            # cpu.max: <max> <period> (e.g. 50000 100000 => 50% CPU)
            "cpu.max": "max 100000",
            # memory.max: bytes, e.g. "536870912" => 512MB
            "memory.max": "1073741824",
        },
    }

    record_and_report_deps(meta, [runner])
    save_meta(name, meta)

    print("Container created:", name)


# ============================================================
#  BUILD (AUTO)
# ============================================================

def cmd_build():
    if len(sys.argv) < 3:
        print("Usage: zocker build <file>")
        return

    filename = sys.argv[2]
    if not Path(filename).exists():
        print("File not found:", filename)
        return

    ext = Path(filename).suffix
    name = generate_name()
    folder = CONTAINERS_ROOT / name
    folder.mkdir(parents=True)

    _, lower, upper, work, merged = ensure_fs_tree(name)
    shutil.copy(filename, lower / filename)

    runner = None
    default_cmd = None

    if ext == ".cpp":
        runner = "g++"
        exe = "app"
        print("Compiling inside container 'lower' layer...")
        subprocess.run(["g++", filename, "-o", exe], cwd=lower)
        default_cmd = ["./app"]

    elif ext == ".py":
        runner = "python3"
        default_cmd = ["python3", filename]

    elif ext == ".js":
        runner = "node"
        default_cmd = ["node", filename]

    elif ext == ".sh":
        runner = "bash"
        default_cmd = ["bash", filename]

    elif ext == ".html":
        runner = "w3m"
        default_cmd = ["w3m", filename]

    else:
        print("Unsupported file type:", ext)
        return

    color = random.choice(COLORS)

    meta = {
        "name": name,
        "status": "built",
        "runner": runner,
        "command": default_cmd,
        "pid": None,
        "color": color,
        "cpu": "high",
        "overlay": False,
        "limits": {
            "cpu.max": "max 100000",
            "memory.max": "1073741824",
        },
    }

    record_and_report_deps(meta, [runner])
    save_meta(name, meta)

    print("\nZocker Build Completed")
    print("Container:", name)
    print("Default command:", default_cmd)
    print("Status: built")


# ============================================================
#  REAL BASH SHELL (chroot + namespaces when available)
# ============================================================

def container_true_shell(name, rootdir, meta):
    env = {}
    # Minimal, container-y environment
    env["PS1"] = f"{name}# "
    env["ZOCKER_CONTAINER"] = name
    env["HOME"] = "/root"
    env["PATH"] = "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

    print("\n[Entering REAL container shell]")
    print("This shell tries to use chroot + Linux namespaces if available.")
    print("Type 'exit' to come back.\n")

    rootdir = Path(rootdir)

    # Prefer full isolation via unshare + chroot, if root and util available
    if is_root() and check_dependency("unshare"):
        cmd = [
            "unshare",
            "--uts",
            "--ipc",
            "--pid",
            "--net",
            "--mount-proc",
            "--fork",
            "chroot",
            str(rootdir),
            "bash",
        ]
        try:
            # Best-effort: also join cgroup if configured
            cg_path_str = meta.get("cgroup_path")
            if cg_path_str:
                # We can't directly stuff the bash PID beforehand, but bash
                # will be the only heavy process anyway; user can manually
                # echo $$ > cgroup.procs from inside if they want.
                print(f"[cgroup] Shell will run under cgroup: {cg_path_str}")
            subprocess.call(cmd, env=env)
        except FileNotFoundError:
            print("unshare or chroot not found; falling back to chroot-only / plain bash.")
    elif is_root() and check_dependency("chroot"):
        # Chroot-only isolation
        cmd = ["chroot", str(rootdir), "bash"]
        subprocess.call(cmd, env=env)
    else:
        # Non-root fallback: just cd into the container FS
        print("[isolation] Not root – cannot chroot or unshare. ")
        print("            Running normal bash with cwd inside container FS.")
        subprocess.call(["bash"], cwd=rootdir, env=env)

    print("\n[Leaving REAL container shell]\n")


# ============================================================
#  ZOCKER SHELL (COMMAND DISPATCHER)
# ============================================================

def run_in_container_fs(rootdir: Path, cmd_list, use_chroot: bool, meta: dict):
    """
    Helper: run a command either directly in rootdir (non-root)
    or via chroot <rootdir> (root).
    """
    rootdir = Path(rootdir)
    env = os.environ.copy()
    env["ZOCKER_CONTAINER"] = meta.get("name", "unknown")

    if is_root() and use_chroot and check_dependency("chroot"):
        full_cmd = ["chroot", str(rootdir)] + cmd_list
        proc = subprocess.Popen(
            full_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            env=env,
        )
    else:
        proc = subprocess.Popen(
            cmd_list,
            cwd=rootdir,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            env=env,
        )

    # Try to also drop this process into cgroup (best-effort)
    if is_root():
        cg_path_str = meta.get("cgroup_path")
        if cg_path_str:
            try:
                add_pid_to_cgroup(Path(cg_path_str), proc.pid)
            except Exception:
                pass

    out, err = proc.communicate()
    return out, err


def container_shell(name, rootdir):
    meta = load_meta(name)
    if not meta:
        print("Container not found.")
        return

    color = meta.get("color", RESET)
    log_file = CONTAINERS_ROOT / name / "logs.txt"

    print(color + f"Entering container shell: {name}" + RESET)
    print(color + "Type 'help' for commands." + RESET)

    use_chroot = True  # we decide inside helper based on root + chroot

    while True:
        try:
            cmd = input(color + f"{name} > " + RESET).strip()
        except (KeyboardInterrupt, EOFError):
            print("\nLeaving container shell...")
            break

        if cmd == "":
            continue

        if cmd == "exit":
            print("Leaving container shell...")
            break

        if cmd == "help":
            print(color + """
Zocker Shell Commands:
  pwd              - show current dir (inside container)
  whoami           - show container name
  ls               - list files
  cat <file>       - read file
  clear            - clear screen
  run <file>       - auto run/compile (.cpp, .py, .js, .sh, .html)
  shell            - drop into REAL bash inside container (chroot + namespaces)
  exit             - leave this shell
""" + RESET)
            continue

        if cmd == "whoami":
            print(name)
            continue

        if cmd == "clear":
            print("\n" * 60)
            continue

        if cmd == "shell":
            container_true_shell(name, rootdir, meta)
            continue

        if cmd == "bash":
            print("Use 'shell' command instead of directly running bash.")
            continue

        # run <file>
        if cmd.startswith("run "):
            file = cmd.split(" ", 1)[1]
            fpath = Path(rootdir) / file

            if not fpath.exists():
                print("File not found in container.")
                continue

            # C++ ----------------------------------------------------------
            if file.endswith(".cpp"):
                exe = file.replace(".cpp", "")
                if not check_dependency("g++"):
                    print("[MISSING] g++ not found.")
                    print("          Install with:", INSTALL_HINTS["g++"])
                else:
                    # compile
                    compile_cmd = ["bash", "-c", f"g++ {file} -o {exe}"]
                    out, err = run_in_container_fs(rootdir, compile_cmd, use_chroot, meta)
                    if out:
                        print(color + out.decode(errors="ignore") + RESET, end="")
                    if err:
                        print(color + err.decode(errors="ignore") + RESET, end="")
                    # run
                    run_cmd = ["bash", "-c", f"./{exe}"]
                    out, err = run_in_container_fs(rootdir, run_cmd, use_chroot, meta)
                    if out:
                        print(color + out.decode(errors="ignore") + RESET, end="")
                    if err:
                        print(color + err.decode(errors="ignore") + RESET, end="")
                continue

            # Python -------------------------------------------------------
            if file.endswith(".py"):
                if not check_dependency("python3"):
                    print("[MISSING] python3 not found.")
                    print("          Install with:", INSTALL_HINTS["python3"])
                else:
                    run_cmd = ["bash", "-c", f"python3 {file}"]
                    out, err = run_in_container_fs(rootdir, run_cmd, use_chroot, meta)
                    if out:
                        print(color + out.decode(errors="ignore") + RESET, end="")
                    if err:
                        print(color + err.decode(errors="ignore") + RESET, end="")
                continue

            # JS -----------------------------------------------------------
            if file.endswith(".js"):
                if not check_dependency("node"):
                    print("[MISSING] node not found.")
                    print("          Install with:", INSTALL_HINTS["node"])
                else:
                    run_cmd = ["bash", "-c", f"node {file}"]
                    out, err = run_in_container_fs(rootdir, run_cmd, use_chroot, meta)
                    if out:
                        print(color + out.decode(errors="ignore") + RESET, end="")
                    if err:
                        print(color + err.decode(errors="ignore") + RESET, end="")
                continue

            # HTML ---------------------------------------------------------
            if file.endswith(".html"):
                if not check_dependency("w3m"):
                    print("[MISSING] w3m not found.")
                    print("          Install with:", INSTALL_HINTS["w3m"])
                else:
                    run_cmd = ["bash", "-c", f"w3m {file}"]
                    out, err = run_in_container_fs(rootdir, run_cmd, use_chroot, meta)
                    if out:
                        print(color + out.decode(errors="ignore") + RESET, end="")
                    if err:
                        print(color + err.decode(errors="ignore") + RESET, end="")
                continue

            # Shell script -------------------------------------------------
            if file.endswith(".sh"):
                run_cmd = ["bash", "-c", f"bash {file}"]
                out, err = run_in_container_fs(rootdir, run_cmd, use_chroot, meta)
                if out:
                    print(color + out.decode(errors="ignore") + RESET, end="")
                if err:
                    print(color + err.decode(errors="ignore") + RESET, end="")
                continue

            print("Unsupported file type for 'run'.")
            continue

        # Normal Linux command inside container fs ------------------------
        out, err = run_in_container_fs(rootdir, ["bash", "-c", cmd], use_chroot, meta)

        if out:
            print(color + out.decode(errors="ignore") + RESET, end="")
        if err:
            print(color + err.decode(errors="ignore") + RESET, end="")

        with open(log_file, "ab") as lf:
            lf.write(out)
            lf.write(err)


# ============================================================
#  RUN (WITH OVERLAY + CGROUPS)
# ============================================================

def cmd_run():
    if len(sys.argv) < 3:
        print("Usage: zocker run <container-name>")
        return

    name = sys.argv[2]
    meta = load_meta(name)
    if not meta:
        print("Container not found.")
        return

    # Try overlay mount
    rootdir, overlay_active = setup_overlay(name)
    meta["overlay"] = overlay_active

    # Setup cgroup (best-effort)
    cg_path = setup_cgroup(name, meta)

    # Fake PID for visual effect
    if meta.get("pid") is None:
        meta["pid"] = random.randint(20000, 50000)
    meta["status"] = "running"
    save_meta(name, meta)

    print(f"Container {name} started (PID={meta['pid']})")
    print(f"(rootdir: {rootdir})")
    if cg_path:
        print(f"(cgroup: {cg_path})")

    try:
        container_shell(name, rootdir)
    finally:
        # on leaving shell: mark stopped, unmount overlay if needed
        teardown_overlay(name, overlay_active)
        meta = load_meta(name) or {}
        meta["status"] = "stopped"
        meta["pid"] = None
        meta["overlay"] = False
        teardown_cgroup(meta)
        save_meta(name, meta)
        print(f"Container {name} stopped.")


# ============================================================
#  STOP / STOP-ALL
# ============================================================

def cmd_stop():
    if len(sys.argv) < 3:
        print("Usage: zocker stop <name>")
        return

    name = sys.argv[2]
    meta = load_meta(name)
    if not meta:
        print("Container not found.")
        return

    # Nothing actually running in background; just update status
    meta["status"] = "stopped"
    meta["pid"] = None
    meta["overlay"] = False
    teardown_cgroup(meta)
    save_meta(name, meta)

    # Also try to unmount overlay if left mounted
    teardown_overlay(name, True)
    print("Stopped:", name)


def cmd_stop_all():
    print("Stopping ALL containers...")
    for folder in CONTAINERS_ROOT.iterdir():
        meta_file = folder / "meta.json"
        if not meta_file.exists():
            continue
        with open(meta_file, "r") as f:
            meta = json.load(f)
        name = meta.get("name")
        meta["status"] = "stopped"
        meta["pid"] = None
        meta["overlay"] = False
        teardown_cgroup(meta)
        save_meta(name, meta)
        teardown_overlay(name, True)
        print("Stopped:", name)
    print("Done.")


# ============================================================
#  REMOVE / RM-ALL
# ============================================================

def cmd_rm():
    if len(sys.argv) < 3:
        print("Usage: zocker rm <name>")
        return

    name = sys.argv[2]
    folder = CONTAINERS_ROOT / name
    if not folder.exists():
        print("Container not found.")
        return

    meta = load_meta(name)
    if meta and meta.get("status") == "running":
        print("Container is running; stop it first.")
        return

    if meta:
        teardown_cgroup(meta)
    teardown_overlay(name, True)
    shutil.rmtree(folder)
    print("Removed:", name)


def cmd_rm_all():
    print("Removing ALL stopped containers...")
    for folder in CONTAINERS_ROOT.iterdir():
        meta_file = folder / "meta.json"
        if not meta_file.exists():
            continue
        meta = json.load(open(meta_file))
        name = meta.get("name")
        if meta.get("status") == "running":
            print(f"Skipping running container: {name}")
            continue
        teardown_cgroup(meta)
        teardown_overlay(name, True)
        shutil.rmtree(folder)
        print("Removed:", name)
    print("Done.")


# ============================================================
#  PS / LOGS / INSPECT
# ============================================================

def cmd_ps():
    rows = []
    for folder in CONTAINERS_ROOT.iterdir():
        meta_file = folder / "meta.json"
        if not meta_file.exists():
            continue
        m = json.load(open(meta_file))
        rows.append([
            m.get("name", ""),
            str(m.get("pid", "")),
            m.get("status", ""),
            " ".join(m.get("command", []))
        ])

    if not rows:
        print("No containers found.")
        return

    print("+----------------------+--------+----------+-------------------------------+")
    print("| Name                 | PID    | Status   | Command                       |")
    print("+----------------------+--------+----------+-------------------------------+")
    for r in rows:
        print("| {:<20} | {:<6} | {:<8} | {:<29} |".format(*r))
    print("+----------------------+--------+----------+-------------------------------+")


def cmd_logs():
    if len(sys.argv) < 3:
        print("Usage: zocker logs <name>")
        return

    name = sys.argv[2]
    log_file = CONTAINERS_ROOT / name / "logs.txt"
    if log_file.exists():
        print(log_file.read_text())
    else:
        print("No logs found.")


def cmd_inspect():
    if len(sys.argv) < 3:
        print("Usage: zocker inspect <name>")
        return

    name = sys.argv[2]
    meta_file = CONTAINERS_ROOT / name / "meta.json"
    if meta_file.exists():
        print(meta_file.read_text())
    else:
        print("Container not found.")


# ============================================================
#  EXPORT / IMPORT
# ============================================================

def cmd_export():
    if len(sys.argv) < 4:
        print("Usage: zocker export <name> <file.tar>")
        return

    name = sys.argv[2]
    outfile = sys.argv[3]
    container_path = CONTAINERS_ROOT / name

    if not container_path.exists():
        print("Container not found.")
        return

    base = outfile.replace(".tar", "")
    shutil.make_archive(base, "tar", container_path)
    print(f"Container '{name}' exported to: {outfile}")


def cmd_import():
    if len(sys.argv) < 3:
        print("Usage: zocker import <file.tar>")
        return

    tarfile = sys.argv[2]
    if not Path(tarfile).exists():
        print("File not found:", tarfile)
        return

    newname = generate_name()
    newpath = CONTAINERS_ROOT / newname
    newpath.mkdir(parents=True)

    shutil.unpack_archive(tarfile, newpath)

    meta_file = newpath / "meta.json"
    if meta_file.exists():
        meta = json.load(open(meta_file))
        meta["name"] = newname
        meta["pid"] = None
        meta["overlay"] = False
        save_meta(newname, meta)

    print(f"Container imported as: {newname}")


# ============================================================
#  COMMAND ROUTER
# ============================================================

def main():
    if len(sys.argv) < 2:
        print("No command given.")
        sys.exit(1)

    cmd = sys.argv[1]

    if cmd == "create":
        cmd_create()
    elif cmd == "build":
        cmd_build()
    elif cmd == "run":
        cmd_run()
    elif cmd == "stop":
        cmd_stop()
    elif cmd == "stop-all":
        cmd_stop_all()
    elif cmd == "rm":
        cmd_rm()
    elif cmd == "rm-all":
        cmd_rm_all()
    elif cmd == "ps":
        cmd_ps()
    elif cmd == "logs":
        cmd_logs()
    elif cmd == "inspect":
        cmd_inspect()
    elif cmd == "export":
        cmd_export()
    elif cmd == "import":
        cmd_import()
    else:
        print("Unknown command:", cmd)


if _name_ == "_main_":
    main()
